{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:"
	"cpp template": {
		"prefix": "tmp",
		"body": [
			"//In the name of ALLAH\n",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"typedef long long ll;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"typedef vector<vl> vvl;",
			"typedef vector<vi> vvi;",
			"typedef pair<int, int> pii;",
			"typedef pair<double, double> pdd;",
			"typedef pair<ll, ll> pll;",
			"typedef vector<pii> vii;",
			"typedef vector<pll> vll;",
			"typedef double dl;\n",
			"#define PB push_back",
			"#define F first",
			"#define S second",
			"#define MP make_pair",
			"#define fo(a, n) for(int i = a; i < n; i++)",
			"#define endl '\\n'",
			"#define all(a) (a).begin(), (a).end()",
			"#define sz(x) (int)x.size()",
			"#define mid(l, r) ((r + l) / 2)",
			"#define left(node) (node * 2)",
			"#define right(node) (node * 2 + 1)",
			"#define mx_int_prime 999999937\n",
			"const double PI = acos(-1);",
			"const double eps = 1e-9;",
			"const int inf = 2000000000;",
			"const ll infLL = 9000000000000000000;\n",
			"#define MOD 1000000007",
			"#define mem(a, b) memset(a, b, sizeof(a) )",
			"#define gcd(a, b) __gcd(a, b)",
			"ll lcm(ll a, ll b)",
			"{",
			"    return a * (b / gcd(a, b));",
			"}",
			"#define sqr(a) ((a) * (a))\n",
			"#define optimize()                \\",
			"\tios_base::sync_with_stdio(0); \\",
			"\tcin.tie(0);                   \\",
			"\tcout.tie(0);",
			"#define fraction(a)               \\",
			"\tcout.unsetf(ios::floatfield); \\",
			"\tcout.precision(a);            \\",
			"\tcout.setf(ios::fixed, ios::floatfield);",
			"#define file()                        \\",
			"\tfreopen('input.txt', 'r', stdin); \\",
			"\tfreopen('output.txt', 'w', stdout);\n",
			"typedef vector<int>::iterator vit;",
			"typedef set<int>::iterator sit;\n",
			"//int dx[] = {0, 0, +1, -1};",
			"//int dy[] = {+1, -1, 0, 0};",
			"//int dx[] = {+1, 0, -1, 0, +1, +1, -1, -1};",
			"//int dy[] = {0, +1, 0, -1, +1, -1, +1, -1};\n",
			"template <typename F, typename S>",
			"ostream &operator<<(ostream& os, const pair<F, S> &p) ",
			"{",
			"return os << '(' << p.first << ',' << p.second << ')';",
			"}",
			"template <typename T>",
			"ostream &operator << (ostream &os, const vector<T> &v) ",
			"{",
			"\tos << '{';",
			"\tfor(auto it = v.begin(); it != v.end(); ++it) ",
			"\t{",
			"\t\tif( it != v.begin() ) ",
			"\t\t\tos << ',' ;",
			"\t\tos << *it;",
			"\t}",
			"\treturn os << ',' << ' '; ",
			"}\n",
			"template <typename T>",
			"ostream &operator << (ostream &os, const set<T> &v) ",
			"{",
			"\tos << '[';",
			"\tfor(auto it = v.begin(); it != v.end(); ++it) ",
			"\t{",
			"\t\tif( it != v.begin() ) ",
			"\t\t\tos << ',';",
			"\t\tos << *it;",
			"\t}",
			"\treturn os << ']';",
			"}\n",
			"template <typename T>",
			"ostream &operator << (ostream &os, const multiset<T> &v) ",
			"{",
			"\tos << '[';",
			"\tfor(auto it = v.begin(); it != v.end(); ++it) ",
			"\t{",
			"\t\tif( it != v.begin() ) ",
			"\t\t\tos << ',';",
			"\t\tos << *it;",
			"\t}",
			"\treturn os << ']';",
			"}\n",
			"template < typename F, typename S >",
			"ostream &operator << ( ostream & os, const map< F, S > &v ) ",
			"{",
			"\tos << '[';",
			"\tfor(auto it = v.begin(); it != v.end(); ++it) ",
			"\t{",
			"\t\tif( it != v.begin() ) ",
			"\t\t\tos << ',';",
			"\t\tos << it->first << ' ' << '=' << ' ' << it->second;",
			"\t}",
			"\treturn os << ']';",
			"}\n",
			"#define dbg(args...)                        \\",
			"\tdo                                      \\",
			"\t{                                       \\",
			"\t\tcerr << #args << ' ' << ':' << ' '; \\",
			"\t\tfanc(args);                         \\",
			"\t} while (0)",
			"void fanc()",
			"{",
			"\tcerr << endl;",
			"}\n",
			"template <typename T>",
			"void fanc(T a[], int n) ",
			"{",
			"\tfor (int i = 0; i < n; ++i) ",
			"\t\tcerr << a[i] << ' ';",
			"\tcerr << endl;",
			"}\n",
			"template <typename T, typename... hello>",
			"void fanc(T arg, const hello &...rest) ",
			"{",
			"\tcerr << arg << ' ';",
			"\tfanc(rest...);",
			"}\n",
			"void solution(){",
			"\t$2",
			"}\n",
			"int main()",
			"{",
			"\toptimize();",
			"\tint t = 1;",
			"\t//$1  cin >> t;",
			"\twhile (t--)",
			"\t{",
			"\t\tsolution();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "This is a boilerplate"
	},
	
	"Prime Generation Function": {
		"prefix": "GeneratePrime",
		"body": [
			"const int mx = 1e$1 + 123;",
			"bitset<mx> isPrime;",
			"vi primes;",
			"void primeGen(int n)",
			"{",
			"     n += 100;",
			"    for (int i = 3; i <= n; i += 2)",
			"        isPrime[i] = 1;",
			"    int sq = sqrt(n);",
			"",
			"    for (int i = 3; i <= sq; i += 2)",
			"    {",
			"        if (isPrime[i])",
			"        {",
			"            for (int j = i * i; j <= n; j += (i + i))",
			"            {",
			"                isPrime[j] = 0;",
			"            }",
			"        }",
			"    }",
			"    isPrime[2] = 1;",
			"    primes.PB(2);",
			"    for (int i = 3; i <= n; i += 2)",
			"    {",
			"        if (isPrime[i])",
			"            primes.PB(i);",
			"    }",
			"}"
		]
	}
}